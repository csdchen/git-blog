# <center>设计模式</center>
参考:

[c语言中文网](http://c.biancheng.net/design_pattern/)  
`李建忠老师视频`  
`Head+First设计模式`

## 六大原则
### 依赖倒置原则
```
高层模块(稳定)不应该低层模块(变化), 二者都应该依赖于抽象(稳定)
抽象(稳定)不应该依赖实现细节(变化), 实现细节应该依赖于抽象(稳定)
```
### 开放封闭原则
```
当应用的需求改变时，在不修改软件实体的源代码或者二进制代码的前提下，可以扩展模块的功能，使其满足新的需求
```
### 单一职责原则
```
一个类应该仅有一个引起它变化的原因
变化的方向隐含着类的责任
```
### 里氏替换原则
```
子类必须能够替换它们的基类
子类可以扩展父类的功能，但不能改变父类原有的功能
```
### 接口隔离原则
```
不应该强迫客户程序依赖它们不用的方法
接口应该小而完备
```
### 合成复用原则
```
优先对象组合, 不是类继承
继承在某种程度上破坏了封装性,子类父类耦合度高
```
### 最少知识原则-迪米特法则
```
两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性
```
- 缺点: 过度使用迪米特法则会使系统产生大量的中介类，从而增加系统的复杂性，使模块之间的通信效率降低

## 模式

### 单例模式
```
指一个类只有一个实例，且该类能自行创建这个实例的一种模式
```
- 缺点 : 多线程有风险
- [代码实现](./src/designmode/single.hpp)

### 观察者模式
```
多个对象间存在一对多的依赖关系, 当一个对象的状态发生改变时, 所有依赖于它的对象都得到通知并被自动更新
```
- 优点 : 观察者与主题之间用松耦合方式结合, 主题不知道可观察者的细节
- 缺点 : 通知无序
- 缺点 : 目标与观察者之间的依赖关系并没有完全解除, 而且有可能出现循环引用
- [代码实现](./src/designmode/observer.hpp)

### 装饰模式
```
解决主体类在多个方向上的扩展功能, 并非解决多子类衍生的多继承问题
实现在运行时动态使用扩展对象功能的能力
```
- 优点 : 可以设计出多个不同的具体装饰类，创造出多个不同行为的组合
- 缺点 : 
- [代码实现](./src/designmode/decorate.hpp)

### 桥模式
```
将抽象与实现分离，使它们可以独立变化。
用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度
```
- 优点 : 抽象与实现分离, 扩展能力强
- 优点 : 其实现细节对客户透明
- 缺点 : 由于聚合关系建立在抽象层, 要求开发者针对抽象化进行设计与编程, 这增加了系统的理解与设计难度
- [代码实现](./src/designmode/bridge.hpp)

### 工厂方法模式
```
定义一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到具体子工厂类当中
用于隔离类对象的使用者和具体类型之间的耦合关系
面对一个经常变化的具体类型, 紧耦合关系(new)会导致软件的脆弱
```
- 优点 : 
- 优点 : 
- 缺点 : 每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类
- [代码实现](./src/designmode/factoryMethod.hpp)

### 抽像工厂模式
```
是一种为访问类提供一个创建一组相关或相互依赖对象的接口
工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品
```
- 优点 : 
- 优点 : 增加一个新的产品族时不需要修改原代码
- 缺点 : 当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改
- [代码实现](./src/designmode/abstractFactory.hpp)

### 原型模式
```
用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象
```
- 优点 : 无须知道对象创建的细节
- `特点` : 原型模式的克隆分为浅克隆和深克隆
- 缺点 : 
- [代码实现](./src/designmode/protype.hpp)

### Bulider模式
```
指将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示
```
- 优点 : 各个具体的建造者相互独立
- 优点 : 客户端不必知道产品内部组成的细节
- 缺点 : 产品的组成部分必须相同
- 缺点 : 产品的内部变化复杂，该模式会增加很多的建造者类

- [代码实现](./src/designmode/bulider.hpp)

### 享元模式
```
运用共享技术来有効地支持大量细粒度对象的复用
```
- 优点 : 相同对象只要保存一份，这降低了系统中对象的数量
- 缺点 : 为了使对象可以共享，需要将一些不能共享的状态外部化，这将增加程序的复杂性
- 缺点 : 读取享元模式的外部状态会使得运行时间稍微变长
- 例如 : 线程池 对象池 内存池
- [代码实现](./src/designmode/flyweight.hpp)

### 外观模式
```
是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式
```
- 优点 : 降低了子系统与客户端之间的耦合度
- 优点 : 降低了大型软件系统中的编译依赖性
- 优点 : 对客户屏蔽了子系统组件，减少了客户处理的对象数目
- 缺点 : 不能很好地限制客户使用子系统类
- 缺点 : 增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”
- [代码实现](./src/designmode/facade.hpp)

### 代理模式
```
由于某些原因需要给某对象提供一个代理以控制对该对象的访问。
这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介
```
- 优点 : 代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用
- 优点 : 代理对象可以扩展目标对象的功能
- 缺点 : 在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢
- [代码实现](./src/designmode/proxy.hpp)

### 适配器模式
```
使用一个已经存在的类，如果它的接口和你实际要求的不一致时，可以考虑使用适配器模式
要在调用者和功能提供者双方都不太容易修改的时候再使用适配器模式，而不是一有不同时就使用它
```
- 优点 : 客户端通过适配器可以透明地调用目标接口
- 优点 : 复用了现存的类，程序员不需要修改原有代码而重用现有的适配者类
- 缺点 : 对类适配器来说，更换适配器的实现过程比较复杂
- 类适配器
    - 特点 : 
    ```
    Adapter直接继承自Adaptee类，在Adapter类中可以对Adaptee类的方法进行重定义
    如果在Adaptee中添加了一个抽象方法，那么Adapter也要进行相应的改动，这样就带来高耦合
    如果Adaptee还有其它子类，而在Adapter中想调用Adaptee其它子类的方法时，使用类适配器是无法做到的。
    ```
- 对象适配器
    - 特点 : 
    ```
    不是很容易去构造一个Adaptee类型的对象
    当Adaptee中添加新的抽象方法时，Adapter类不需要做任何调整，也能正确的进行动作
    ```
- [代码实现](./src/designmode/adapter.hpp)

### 中介者模式
```
定义一个中介对象来封装一系列对象之间的交互，使原有对象之间的耦合松散，且可以独立地改变它们之间的交互
```
```
facade模式是解耦系统间(单向)的对象关联关系;
mediator模式是角耦系统内各个对象之间(双向)的关联关系
```
- 优点 : 将对象间的一对多关联转变为一对一的关联
- 优点 : 
- 缺点 : 当同事类太多时，中介者的职责将很大，它会变得复杂而庞大，以至于系统难以维护
- [代码实现](./src/designmode/mediator.hpp)

### 状态模式
```
对有状态的对象，把复杂的“判断逻辑”提取到不同的状态对象中
```
- 优点 : 
- 优点 : 
- 缺点 : 
- [代码实现](./src/designmode/status.hpp)






[主目录](../README.md)